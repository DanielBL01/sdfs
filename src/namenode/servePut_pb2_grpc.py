# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import servePut_pb2 as servePut__pb2


class ServePutStub(object):
    """

    --- FIRST ITERATION OF DESIGN ---

    What do we want to implement in our protocol buffer such that the NameNode service and the DataNode service 
    can communicate with each other to manipulate files?

    For now the DataNode will be responsible for simply storing files based on leader-based replication.

    This means the NameNode will be the only client-facing node where when a client can write a file into the database
    For now, we will replicate the files onto the DataNodes but this is only to learn the mechanism of the NameNode sending
    something to the DataNode. In the future, these files should be broken into blocks like HDFS and stored in DataNodes 
    where the NameNode should know where all the blocks exist for a single file.

    For now, we will support very small files such that the entire file can be put in a single message as byte. This 
    should be very straight-forward.


    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.PutFile = channel.unary_unary(
                '/ServePut/PutFile',
                request_serializer=servePut__pb2.PutFileRequest.SerializeToString,
                response_deserializer=servePut__pb2.PutFileResponse.FromString,
                )


class ServePutServicer(object):
    """

    --- FIRST ITERATION OF DESIGN ---

    What do we want to implement in our protocol buffer such that the NameNode service and the DataNode service 
    can communicate with each other to manipulate files?

    For now the DataNode will be responsible for simply storing files based on leader-based replication.

    This means the NameNode will be the only client-facing node where when a client can write a file into the database
    For now, we will replicate the files onto the DataNodes but this is only to learn the mechanism of the NameNode sending
    something to the DataNode. In the future, these files should be broken into blocks like HDFS and stored in DataNodes 
    where the NameNode should know where all the blocks exist for a single file.

    For now, we will support very small files such that the entire file can be put in a single message as byte. This 
    should be very straight-forward.


    """

    def PutFile(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ServePutServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'PutFile': grpc.unary_unary_rpc_method_handler(
                    servicer.PutFile,
                    request_deserializer=servePut__pb2.PutFileRequest.FromString,
                    response_serializer=servePut__pb2.PutFileResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ServePut', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class ServePut(object):
    """

    --- FIRST ITERATION OF DESIGN ---

    What do we want to implement in our protocol buffer such that the NameNode service and the DataNode service 
    can communicate with each other to manipulate files?

    For now the DataNode will be responsible for simply storing files based on leader-based replication.

    This means the NameNode will be the only client-facing node where when a client can write a file into the database
    For now, we will replicate the files onto the DataNodes but this is only to learn the mechanism of the NameNode sending
    something to the DataNode. In the future, these files should be broken into blocks like HDFS and stored in DataNodes 
    where the NameNode should know where all the blocks exist for a single file.

    For now, we will support very small files such that the entire file can be put in a single message as byte. This 
    should be very straight-forward.


    """

    @staticmethod
    def PutFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ServePut/PutFile',
            servePut__pb2.PutFileRequest.SerializeToString,
            servePut__pb2.PutFileResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
